# 深入理解Java虚拟机-垃圾回收

## 概述

**垃圾回收（Garbage Collection，简称GC）**诞生于麻省理工学院的Lisp语言，主要涉及内存动态分配及内存回收技术。

JVM内存结构包括程序计数器、虚拟机栈、本地方法栈、堆、方法区五个部分，其中程序计数器、虚拟机栈、本地方法栈是线程私有的，故不需要考虑垃圾回收问题，而堆和方法区的分配和回收是动态的，故需要进行垃圾回收。

## 如何判断对象是否可以被回收

### 引用计数法

引用计数法（Reference Counting）是指在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就会+1，任何时刻计数器为0时对象就是不可能再被使用。

优点：原理简单，判断效率高。

缺点：引用计数无法解决循环依赖问题。

![6_引用计数法](D:\study_note\maningning1.github.io\images\jvm\6_引用计数法.png)

故Java虚拟机没有使用引用计数法来管理内存。

### 可达性分析

因为引用计数法存在的问题，Java虚拟机等主流的商用程序语言都是通过可达性分析（Reachability Analysis）算法来判断对象是否存活。这个算法的思想是通过一个根对象（GC Roots）作为起点，根据引用关系向下搜索，如下图所示，对象object5、object6、object7虽然互有关联，但是他们的根不可达，故会被判定为可回收对象。

![1.7_可达性分析](D:\study_note\maningning1.github.io\images\jvm\1.7_可达性分析.png)

在Java中，GC Roots包括以下几种：

+ 虚拟机栈引用的对象（栈中的参数、局部变量、临时变量等）
+ 方法区中静态属性引用的对象（静态变量）
+ 方法区中常量引用的对象（字符串常量池StringTable中的引用）
+ 本地方法栈中JNI引用的对象（native方法）
+ Java虚拟机内部的引用（如基本数据类型对应的Class对象、系统加载类、常驻的异常对象等）
+ 同步锁持有的对象（synchronize）
+ 反映Java虚拟机内部情况的JMX Bean、JVM TI中注册的回调、本地代码缓存等

即使可达性分析判定其为不可达对象，也是需要经历两次标记过程：如果没有与GC Roots相连的引用链，则会第一次标记；随后一次筛选会判断是否有必要执行`finalize()`方法，如果没有则会第二次标记，标记成功的对象就会被回收，如果再`finalize()`方法中与引用链重新建立了关联关系，则可以逃离本次回收。

### 引用

Java中对引用的定义为：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称概reference是代表某块内存、某个对象的引用。在JDK1.2之后，Java为了对对象状态扩展，将引用分为了**强引用（Strongly Reference）**、**软引用（Soft Reference）**、**弱引用（Weak Reference）**、**虚引用（Phantom Reference）**。

#### 强引用

强引用是程序中最普遍存在的引用赋值，当内存空间不足时，JVM宁愿抛出OOM错误使程序异常终止也不会回收强引用对象，只有可达性分析不到时才会被回收。

```java
public static void main(String[] args) {
    Student student = new Student();
    student = null;
    System.gc();
}
```

#### 软引用

软引用是用来描述一些还有用但非必须的对象，被软引用关联的对象，在系统将要内存溢出前，会将这些对象列进回收范围进行第二次回收，如果这次回收后内存不足，才会报出OOM异常，使用`SoftReference`类实现。

```java
// -Xmx20M
public static void main(String[] args) {
    SoftReference<byte[]> softReference = new SoftReference<>(new byte[_10MB]);
    // [B@4554617c
    System.out.println(softReference.get());
    System.gc();
    // [B@4554617c
    System.out.println(softReference.get());

    byte[] bytes = new byte[_10MB];
    // null
    System.out.println(softReference.get());
}
```

如上代码所示，软引用在内存不够的时候才会被回收，故显式调用gc时因为内存充足，所以对象并不会被回收，在新建10mb对象后，内存不足导致gc就会将虚引用中的对象优先回收掉。

软引用可以用来实现内存敏感的高速缓存。

当软引用所关联的对象被回收时，软引用自己就会被加到与之关联的引用队列中，代码如下所示。

```java
// -Xmx20M
public static void main(String[] args) {
    ReferenceQueue<byte[]> queue = new ReferenceQueue<>();
    List<SoftReference<byte[]>> list = new ArrayList<>();
    // 添加15m对象
    for (int i = 0; i < 3; i++) {
        SoftReference<byte[]> ref = new SoftReference<>(new byte[_5MB], queue);
        list.add(ref);
    }

    for (SoftReference<byte[]> aList : list) {
        System.out.println(aList.get());
    }

    Reference<? extends byte[]> poll = queue.poll();
    while (poll != null) {
        System.out.println(poll);
        poll = queue.poll();
    }
    System.out.println("====================");
    // 再添加5m对象，触发gc
    list.add(new SoftReference<>(new byte[_5MB], queue));
    for (SoftReference<byte[]> aList : list) {
        System.out.println(aList.get());
    }

    poll = queue.poll();
    while (poll != null) {
        System.out.println(poll);
        poll = queue.poll();
    }
}
/** 输出
[B@4554617c
[B@74a14482
[B@1540e19d
====================
null
null
null
[B@677327b6
java.lang.ref.SoftReference@14ae5a5
java.lang.ref.SoftReference@7f31245a
java.lang.ref.SoftReference@6d6f6e28
*/
```

#### 弱引用

弱引用用来描述那些非必须对象，比软引用的强度更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，无论当前内存是否足够都会被回收掉，使用`WeakReference`类实现。

```java
public static void main(String[] args) {
    WeakReference<byte[]> weakReference = new WeakReference<>(new byte[1]);
    // [B@4554617c
    System.out.println(weakReference.get());

    System.gc();
    // null
    System.out.println(weakReference.get());
}
```

#### 虚引用

虚引用又称为“幽灵引用”，是最弱的一种引用关系，一个对象是否有虚引用的存在不会对其生存时间构成影响。

虚引用主要用来跟踪对象被垃圾回收器回收的活动，其必须和引用队列联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存前将它加入到与之关联的引用队列中。

```java
public static void main(String[] args) {
    ReferenceQueue queue = new ReferenceQueue();
    PhantomReference<byte[]> reference = new PhantomReference<>(new byte[1], queue);
    System.out.println(reference.get());
}
```

## 垃圾回收算法

### 标记清除算法

有内存碎片，空间不连续

### 标记整理算法

会将碎片整理，因为存在对象的移动，速度较慢

###  复制算法

FROM区、TO区。不会产生碎片，但是会占用双倍的内存空间。

## 分代垃圾回收

分代垃圾回收算法是限制大部分JVM垃圾收集器采用的算法。

新生代处理朝生夕死的对象，老年代处理存活时间长的对象，不同区域采用不同的算法。

## 垃圾回收器

## 调优