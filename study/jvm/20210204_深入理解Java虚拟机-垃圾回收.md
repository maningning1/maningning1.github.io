# 深入理解Java虚拟机-垃圾回收

## 概述

**垃圾回收（Garbage Collection，简称GC）**诞生于麻省理工学院的Lisp语言，主要涉及内存动态分配及内存回收技术。

JVM内存结构包括程序计数器、虚拟机栈、本地方法栈、堆、方法区五个部分，其中程序计数器、虚拟机栈、本地方法栈是线程私有的，故不需要考虑垃圾回收问题，而堆和方法区的分配和回收是动态的，故需要进行垃圾回收。

## 如何判断对象是否可以被回收

### 引用计数法

引用计数法（Reference Counting）是指在对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就会+1，任何时刻计数器为0时对象就是不可能再被使用。

优点：原理简单，判断效率高。

缺点：引用计数无法解决循环依赖问题。

![2.1_引用计数法.png](https://github.com/maningning1/maningning1.github.io/blob/main/images/jvm/2.1_%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95.png?raw=true)

故Java虚拟机没有使用引用计数法来管理内存。

### 可达性分析

因为引用计数法存在的问题，Java虚拟机等主流的商用程序语言都是通过可达性分析（Reachability Analysis）算法来判断对象是否存活。这个算法的思想是通过一个根对象（GC Roots）作为起点，根据引用关系向下搜索，如下图所示，对象object5、object6、object7虽然互有关联，但是他们的根不可达，故会被判定为可回收对象。

![1.7_可达性分析](https://github.com/maningning1/maningning1.github.io/blob/main/images/jvm/2.2_%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png?raw=true)

在Java中，GC Roots包括以下几种：

+ 虚拟机栈引用的对象（栈中的参数、局部变量、临时变量等）
+ 方法区中静态属性引用的对象（静态变量）
+ 方法区中常量引用的对象（字符串常量池StringTable中的引用）
+ 本地方法栈中JNI引用的对象（native方法）
+ Java虚拟机内部的引用（如基本数据类型对应的Class对象、系统加载类、常驻的异常对象等）
+ 同步锁持有的对象（synchronize）
+ 反映Java虚拟机内部情况的JMX Bean、JVM TI中注册的回调、本地代码缓存等

即使可达性分析判定其为不可达对象，也是需要经历两次标记过程：如果没有与GC Roots相连的引用链，则会第一次标记；随后一次筛选会判断是否有必要执行`finalize()`方法，如果没有则会第二次标记，标记成功的对象就会被回收，如果再`finalize()`方法中与引用链重新建立了关联关系，则可以逃离本次回收。

### 引用

Java中对引用的定义为：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称概reference是代表某块内存、某个对象的引用。在JDK1.2之后，Java为了对对象状态扩展，将引用分为了**强引用（Strongly Reference）**、**软引用（Soft Reference）**、**弱引用（Weak Reference）**、**虚引用（Phantom Reference）**。

#### 强引用

强引用是程序中最普遍存在的引用赋值，当内存空间不足时，JVM宁愿抛出OOM错误使程序异常终止也不会回收强引用对象，只有可达性分析不到时才会被回收。

```java
public static void main(String[] args) {
    Student student = new Student();
    student = null;
    System.gc();
}
```

#### 软引用

软引用是用来描述一些还有用但非必须的对象，被软引用关联的对象，在系统将要内存溢出前，会将这些对象列进回收范围进行第二次回收，如果这次回收后内存不足，才会报出OOM异常，使用`SoftReference`类实现。

```java
// -Xmx20M
public static void main(String[] args) {
    SoftReference<byte[]> softReference = new SoftReference<>(new byte[_10MB]);
    // [B@4554617c
    System.out.println(softReference.get());
    System.gc();
    // [B@4554617c
    System.out.println(softReference.get());

    byte[] bytes = new byte[_10MB];
    // null
    System.out.println(softReference.get());
}
```

如上代码所示，软引用在内存不够的时候才会被回收，故显式调用gc时因为内存充足，所以对象并不会被回收，在新建10mb对象后，内存不足导致gc就会将虚引用中的对象优先回收掉。

软引用可以用来实现内存敏感的高速缓存。

当软引用所关联的对象被回收时，软引用自己就会被加到与之关联的引用队列中，代码如下所示。

```java
// -Xmx20M
public static void main(String[] args) {
    ReferenceQueue<byte[]> queue = new ReferenceQueue<>();
    List<SoftReference<byte[]>> list = new ArrayList<>();
    // 添加15m对象
    for (int i = 0; i < 3; i++) {
        SoftReference<byte[]> ref = new SoftReference<>(new byte[_5MB], queue);
        list.add(ref);
    }

    for (SoftReference<byte[]> aList : list) {
        System.out.println(aList.get());
    }

    Reference<? extends byte[]> poll = queue.poll();
    while (poll != null) {
        System.out.println(poll);
        poll = queue.poll();
    }
    System.out.println("====================");
    // 再添加5m对象，触发gc
    list.add(new SoftReference<>(new byte[_5MB], queue));
    for (SoftReference<byte[]> aList : list) {
        System.out.println(aList.get());
    }

    poll = queue.poll();
    while (poll != null) {
        System.out.println(poll);
        poll = queue.poll();
    }
}
/** 输出
[B@4554617c
[B@74a14482
[B@1540e19d
====================
null
null
null
[B@677327b6
java.lang.ref.SoftReference@14ae5a5
java.lang.ref.SoftReference@7f31245a
java.lang.ref.SoftReference@6d6f6e28
*/
```

#### 弱引用

弱引用用来描述那些非必须对象，比软引用的强度更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生为止，无论当前内存是否足够都会被回收掉，使用`WeakReference`类实现。

```java
public static void main(String[] args) {
    WeakReference<byte[]> weakReference = new WeakReference<>(new byte[1]);
    // [B@4554617c
    System.out.println(weakReference.get());

    System.gc();
    // null
    System.out.println(weakReference.get());
}
```

#### 虚引用

虚引用又称为“幽灵引用”，是最弱的一种引用关系，一个对象是否有虚引用的存在不会对其生存时间构成影响。

虚引用主要用来跟踪对象被垃圾回收器回收的活动，其必须和引用队列联合使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存前将它加入到与之关联的引用队列中。

```java
public static void main(String[] args) {
    ReferenceQueue queue = new ReferenceQueue();
    PhantomReference<byte[]> reference = new PhantomReference<>(new byte[1], queue);
    System.out.println(reference.get());
}
```

## 垃圾回收算法

### 标记清除算法

**标记-清除（Mark-Sweep）算法**分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象（或者标记存活对象），再统一回收。

![2.3_标记清除算法](https://github.com/maningning1/maningning1.github.io/blob/main/images/jvm/2.3_%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png?raw=true)

缺点：

+ 执行效率不稳定，如果Java堆中包含大量对象切都需要回收，就有很多标记清除过程；

+ 有内存碎片，空间不连续

### 标记复制算法

标记复制算法简称为复制算法，是为了解决标记清除算法面对大量可回收对象时执行效率低的问题。它将内存划分为大小相等的两块，每次使用一块，每当其中一块内存用完了，就将存活的对象复制到另一块，这样算法仅需复制少量存活的对象，且不会产生碎片，但是会占用双倍的内存空间，而且存活对象多时，复制效率较低。

###  标记整理算法

**标记-整理（Mark-Compact）算法**也是分为标记和整理两个过程，不过后续步骤不是直接对对象进行清理，而是让对象向内存空间的一端移动，来保证内存的连续。

![2.4_标记整理算法](https://github.com/maningning1/maningning1.github.io/blob/main/images/jvm/2.4_%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png?raw=true)

会将碎片整理，因为存在对象的移动，速度较慢，而且这种操作必须暂停用户应用程序才能进行（被称为“Stop The World”）。

## 分代垃圾回收

### 分代回收理论

分代垃圾回收的思想主要建立在三个理论之上：

+ 1、弱分代假说：绝大多数对象朝生夕灭；
+ 2、强分代假说：熬过越多次垃圾收集过程的对象就越难消亡；
+ 3、跨代引用假说：跨代引用相对于同代引用占极少数。

前两个理论奠定了多款垃圾收集器的一致原则：应该将Java堆划分为不同的区域，根据对象年龄（熬过垃圾收集过程的次数）分配到不同区域存储。于是Java堆被划分为了**新生代（Young Generation）**与**老年代（Old Generation）**，在新生代中每次仅会存活少量对象，然后会逐步晋升到老年代。在新生代与老年代中也针对不同的存储思想采用不同的垃圾回收算法（前文提到的标记清除算法、标记整理算法、复制算法）。

第三个理论强调了只有少量老年代会引用新生代的引用，因此我们就不应该为了少量的跨代引用去扫描整个老年代，也不需要浪费空间去记录跨代引用。

### 内存分配策略

故Java堆将内存分为多个区域，新生代处理朝生夕死的对象，老年代处理存活时间长的对象，不同区域采用不同的算法。

![2.5_内存分配策略](https://github.com/maningning1/maningning1.github.io/blob/main/images/jvm/2.5_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5.png?raw=true)

#### 新生代

目前大部分垃圾收集器**新生代都是采用复制算法**，据研究表明新生代98%的对象都熬不过第一轮收集，故**将新生代划分为了一块较大的Eden区和两块较小的Survivor区（默认为8:1:1）**，每次使用Eden区和其中一块Survivor区，当进行回收时将这两块区域中存活的对象复制到另一块Survivor区中，然后清理Eden区和刚才使用过的Survivor区。

+ 新生成的对象都是放在新生代（出了大对象，新生代放不下），新生代就是为了快速处理掉那些生命周期短的对象；
+ 当Eden区没有足够空间时就会触发一次Minor GC（新生代触发的GC，频率较高）；
+ 当Survivor区空间不足以放下Eden区和另一块Survivor区中存活的对象时，就会将存活对象直接放入老年代；

#### 老年代

老年代中存放的对象生命周期都比较长，故老年代的内存也比新生代大（大概比例为2:1）。新生代中每次进行一次复制，对象的年龄将会增加1，在经历N次垃圾回收后仍存活的对象（默认为15次），将会被放入老年代。

若老年代内存满了将会触发一次Major GC（也叫Full GC），Major GC会新生代与老年代都进行回收。

#### 永久代（元空间）

在Java8前叫永久代，也是堆的一部分；Java8后叫元空间，放在本地内存中。该部分垃圾回收的主要内容是**废弃常量**和**无用的类**。

+ 废弃常量：采用可达性分析进行判断；
+ 无用的类：采用以下几个方面进行判断回收：
  + Java堆中不存在该类的实例；
  + 该类的`ClassLoader`已经被回收；
  + 该类的`java.lang.Class`对象没有在任何地方被引用，即**无法在任何地方通过反射访问该类的方法**。

### 垃圾回收算法细节

#### 根节点枚举

分代垃圾回收算法是现在大部分JVM垃圾收集器采用的算法，而上文所有算法都是以可达性分析为基础，故需要先枚举出所有根节点（全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表））。根节点枚举必须要在一个能保证一致性快照中进行，所有必须要暂停所有的用户线程，所以就会面临“Stop The World”的困扰，而查找引用链可以做到与用户线程一起并发。

因为根节点枚举需要停顿，所以我们不可能花费大量时间去扫描方法区，在HotSpot虚拟机中，采用OopMap这个数据结构来达到这个目的。OopMap记录了**栈上本地变量到堆上对象的引用关系**，其是以空间换时间的思想，每当程序运行到安全点（下文介绍）时，就更新自己的OopMap，即可找到这些根节点，这样GC在扫描时就可以直接得知这些信息。

#### 安全点

OopMap可以帮助我们快速完成根节点枚举，但是如果每条指令都生成对应的OopMap，就会需要大量的额外空间，GC成本也会很高，HotSpot虚拟机选择不为每条指令都生成OopMap，而是只在特定位置记录这些信息，这些位置就被称为**安全点（Safepoint）**，即程序只有在到达安全点才能中断。

中断方式主要有抢先式中断和主动式中断，目前几乎所有虚拟机采用的都是主动式中断。

+ 抢先式中断：在GC发生时，把所有线程中断，如果线程中断的地方不在安全点上，则恢复线程，让其执行到安全点上；
+ 主动式中断：在GC发生时，不对线程直接操作，而是设置一个标志，线程执行时主动轮询这个标志，发现标志为真就自己中断挂起。

为了准确安全的回收内存，也需要避免程序长时间运行不进入安全点，所以安全点的选定标准为**是否具有让程序长时间执行的特征**，如方法调用、循环跳转、异常跳转等。

#### 安全区域

在用户线程处于Sleep状态或者Blocked状态时，这时候程序无法响应JVM中断请求这时候线程无法到达安全点，显然JVM也不可能等待程序唤醒，这时就要引入**安全区域（Safe Region）**来解决。安全区域指在一段代码中引用关系不会发生变化，这个区域任意位置GC都是安全的，可以将安全区域看作是安全点的扩展。线程在执行到安全区域的代码时首先标识自己进入了安全区域，GC就不用管进入安全区域的线程了，在线程离开时再检查JVM是否完成了根节点枚举。

#### 记忆集与卡表

**记忆集（Remembered Set）**是用来解决对象跨代引用问题的数据结构，也是使用空间换时间的思想，比如存放老年代对新生代的每一个引用，这样在回收新生代时就可以知道哪些对象被老年代引用不能回收。

记忆集根据记录的精度分为以下三类：

+ 字长精度：记录的是老年代指向新生代地址；
+ 对象精度：记录的是老年代引用的新生代对象；
+ 卡精度：记录的是新生代一段地址是否存在被老年代引用的记录；

**卡表（Card Table）**就是使用“卡精度”实现的记忆集，卡表与记忆集的关系就类似`HashMap`与`Map`的关系。卡表最简单的形式是一个字节数组，在HotSpot中的实现为`CARD_TABLE[this address >> 9] = 0`，也就是说字节数组`CARD_TABLE`中每个元素对应着其标识内存区域中的一个内存块，也称为**卡页（Card Page）**，只要这个卡页中有一个对象被其他区域对象引用，卡表元素的值就变为1（也就是所谓的变脏），在GC时就只需要将此卡页加入一并扫描。

![2.6_卡表](https://github.com/maningning1/maningning1.github.io/blob/main/images/jvm/2.6_%E5%8D%A1%E8%A1%A8.png?raw=true)

#### 写屏障

在HotSpot虚拟机中使用**写屏障（Write Barrier）**来维护卡表状态，其可以看做是“引用类型字段赋值”这个动作的AOP切面，赋值前的写屏障叫做写前屏障，赋值后的写屏障叫做写后屏障。

#### 并发的可达性分析

可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能进行分析，对于根节点枚举这个步骤，其GC Roots相对整个堆还算少数，而且也有OopMap等优化手段，所以停顿时间已经很短了。

“标记”阶段采用**三色标记（Tricolor Marking）**，作为辅助推导：

+ 白色：对象未被垃圾收集器访问；
+ 黑色：对象已被垃圾收集器访问，且所有引用都被扫描过了，其为存活对象；
+ 灰色：对象已被垃圾收集器访问，但还有至少一个引用没被扫描；

但是并发会出现引用更改的问题，对象B为灰色，而用户线程使对象D从对象C的引用变为了对象A的引用，就会导致对象D无法被分析到而被回收，导致程序出现异常。

![2.7_并发的可达性分析](https://github.com/maningning1/maningning1.github.io/blob/main/images/jvm/2.7_%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png?raw=true)

出现问题主要是因为以下两个条件被同时满足：

+ 赋值器插入了一条或多条从黑色到白色的新引用；
+ 赋值器删除了全部从灰色到白色的直接或间接引用；

所以只要破坏其中一个条件就可以解决该问题，最终有以下两种方案：

+ 增量更新：只要黑色对象新加了指向白色对象的引用，则把该引用记录下来，等扫描结束再将以黑色对象为根重新扫描；
+ 原始快照：当灰色对象删除指向白色对象的引用关系时，把这个将要删除的引用记录下来，等扫描结束再将以白色对象为根重新扫描；

增量更新破坏的是第一个条件，使新加的对象都能重新回到引用链上；原始快照破坏的是第二个条件，保证了对象一定在调用链上。**CMS用的增量更新，G1则是原始快照**。

## 垃圾回收器

### 概述

![2.8_垃圾收集器概述](D:\study_note\maningning1.github.io\images\jvm\2.8_垃圾收集器概述.png)

上图展示了七种不同的分代收集器，其中Serial、ParNew、Parallel Scavenger为新生代垃圾收集器；CMS、Serial Old、Parallel Old为老年代垃圾收集器。

新生代与老年代之间连线说明他们可以搭配使用。

### Serial收集器

Serial收集器是最基础的垃圾收集器，用于新生代，俗称串行收集器，基于复制算法实现。其是一个单线程工作的收集器，所以它在进行垃圾回收时必须要暂停其他所有的工作线程，造成大量的**STW（Stop The World）**。

目前该收集器是client级别的默认收集方式，可以通过`-XX:+UseSerialGC`指定。

### ParNew收集器

ParNew收集器是Serial收集器的多线程并行版本，用于新生代，俗称并行收集器，基于复制算法实现。

ParNew默认开启的线程数与CPU数量相同，可以通过`-XX:ParallelGCThreads`来设置线程数。

可以通过`-XX:+UseParNewGC`指定采用该收集器。

### Parallel Scavenger收集器

#### 吞吐量

吞吐量就是处理器用于运行用户代码的时间与总消耗时间的比值，其公式如下，比如虚拟机完成某个任务总耗时为100min，垃圾收集花费1min，则吞吐量就为99%。

```
吞吐量 = 运行用户代码时间/(运行用户代码时间 + 运行垃圾收集时间)
```

高吞吐量可以最高效率地利用处理器资源，而低停顿时间更加适合与用户交互或者需要保证服务质量，所以高吞吐量适合后台运算程序等。

#### Parallel Scavenger

Parallel Scavenger也是一款新生代收集器，其基于复制算法实现，该收集器主要是关注系统吞吐量，故被称为“吞吐量优先收集器”。可以通过`-XX:+UseParallelGC`指定采用该收集器，其主要有以下两个参数设置需要注意：

+ `-XX:MaxGCPauseMillis`：设置最大垃圾收集停顿时间，收集器将尽力保证内存回收花费时间不超过用户设置值，但是停顿时间是以牺牲吞吐量和新生代空间为代价换取的，所以该值设置过小会导致GC频繁；
+ `-XX:GCTimeRatio`：设置吞吐量大小，该值是个0-100的整数，相当于吞吐量的倒数，默认值为99（即允许1%的时间为垃圾收集时间）；

### Serial Old收集器

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，基于标记-整理算法。

### Parallel Old收集器

Parallel Old是Parallel Scavenger收集器的老年代版本，也是一种关注吞吐量的垃圾收集器支持多线程并发收集，基于标记-整理算法。

### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，作用于老年代，其基于标记-清除算法实现，整个过程分为四个步骤：

![2.9_CMS](D:\study_note\maningning1.github.io\images\jvm\2.9_CMS.png)

+ 初始标记：该过程为单线程执行，存在“STW”，但仅需标记GC Roots能直接关联的对象，速度很快。
+ 并发标记：通过GC Roots直接关联的对象遍历整个对象的过程，并发执行，耗时长但不需要“STW”。
+ 重新标记：根据上文（并发的可达性分析），对标记变动的部分采用增量更新的方法重新标记，也需要“STW”。
+ 并发清除：清除标记阶段判断已经死亡的对象，与用户线程并发执行，故不需要“STW”。

整个过程中最耗时的阶段为并发标记与并发清除，但可以与用户线程一起工作，其特点为并发收集、低停顿。

#### 缺点

+ **CMS收集器对资源敏感**

  CMS默认启动的回收线程数为`(处理器核心数量+3)/4`，故处理器核心不足时，CMS对用户程序的影响就比较大，可能会导致用户程序的执行速度大幅降低。

+ **CMS收集器无法处理“浮动垃圾”**

  CMS的并发标记和并发清除阶段是并发执行的，所以程序运行也伴随着新的垃圾的产生，如果这部分垃圾产生在标记过程之后，就会导致该次CMS无法清除掉该垃圾，这部分垃圾就被称为浮动垃圾，所以CMS必须预留一部分空间，不能等老年代满了再执行垃圾回收。如果CMS运行期间内存无法满足程序分配新对象的需要，则会出现一次“并发失败”，此时就会临时启用Serial Old收集器对老年代进行垃圾回收，停顿时间就会很长。

+ **存在大量空间碎片**

  因为CMS是基于标记-清除算法实现的收集器，所以会存在大量空间碎片的问题。

### Garbage First收集器

#### 结构

Garbage First收集器，简称G1收集器，应用在多处理器和大容量内存环境中，同时注重吞吐量和低延时。G1的定位是取代CMS，避免了内存碎片化，且STW更可控。其实现是将堆划分为多个大小相等的Region，在整体上采用标记-整理算法，两个Region间采用复制算法。

![2.10_G1内存结构](D:\study_note\maningning1.github.io\images\jvm\2.10_G1内存结构.png)

G1内存结构如上图所示，G1不再坚持固定大小及固定数量的分代区域划分，而是划分为了多个大小相等的Region，每一个Region均可扮演Eden、Survivor、Old区。在G1中，还有一类特殊的区域叫做Humongous区域，专门用来存储大对象，当对象大小超过Region容量（取值范围为1MB~32Mb，2^N）的一半的时候，就会被放入**N个连续的**Humongous区域。

#### 回收过程

G1虽然保留了新生代和老年代的概念，但是他们不再固定，每次G1将Region作为单次回收的最小单位，G1收集器会根据用户设置的允许最大收集停顿时间（`-XX: MaxGCPauseMillis`，默认为200ms）优先处理收益最大的那些Region，这样虽然不能回收完所有的垃圾，但是保证了G1收集器在有限的时间内尽可能的高效，这也就是“Garbage First”名字的由来。垃圾回收包括了Young GC和Mixed GC

##### Young GC

当Eden区空间耗尽后，就会触发一次Young GC，采用复制算法将Eden区存活的对象复制到Survivor区，并根据年龄晋升到老年代，原来的Region就会被整个回收掉。

Young GC阶段：

+ 1、根扫描：扫描根节点；
+ 2、更新记忆集：处理脏卡队列和更新记忆集；
+ 3、处理记忆集：检查从年轻代指向老年代的对象（与CMS记忆集相反）；
+ 4、复制：将存活对象复制到Survivor区/Old区；
+ 5、处理引用队列：处理软、弱、虚引用；

##### Mixed GC

当老年代对象占比达到一定比例时，就会进行Mixed GC。Mixed GC过程不仅正常回收新生代空间，还会回收部分老年代。

Mixed GC阶段：

+ 1、初始标记：标记所有根节点，会造成STW；
+ 2、并发标记：并发标记可能会被Young GC打断，且在该阶段中如果发现整个Region都是垃圾就会立即清理该Region，同时并发标记还会记录每个Region的对象存活比例；
+ 3、最终标记：修正并发标记的结果，G1采用原始快照法（snapshot-at-the-beginning，SATB）；
+ 4、筛选回收：负责更新Region的统计数据，根据回收价值选择多个Region回收，因为涉及对象的移动，所以该操作也是STW的；

##### Full GC

如果上述方式不能正常工作，就会触发Full GC，G1就会退化为Serial收集器，这时的GC暂停时间就会很长。Full GC触发的条件：

+ 1、拷贝存活对象晋升失败，无可用空闲分区；
+ 2、并发处理过程完成前空间耗尽；

#### 与CMS比较

G1相比CMS优点很多，如分Region的内存结构、可以指定最大停顿时间、按收益回收、内存碎片少等，但是G1相比CMS还有以下一些缺点：

+ **记忆集**

  在CMS中，采用了记忆集（RSet）在老年代中保存了老年代指向新生代的引用。但是在G1中，因为分区太小，而且分区数量过多，所以在在G1中采用记录哪个Region指向该Region的方式进行记录，有着更高的内存负担。

+ **写屏障**

  CMS使用写后屏障来更新维护卡表，而G1除了需要用写后屏障维护卡表，还需要用写前屏障跟踪并发标记指针变化，所以G1将写屏障放入类似于消息队列的结构中异步处理，而CMS的写屏障则同步就处理了。

## 调优

GC优化很多时候就是减少“STW”的发生。