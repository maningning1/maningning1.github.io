# 索引

## 概述

MySQL的所有数据都是以文件的形式存储在磁盘上的，但是从磁盘上**随机访问**对应的数据非常耗时，故MySQL读取数据不是以行为单位，而是以**页**为单位进行读取，减少随机IO次数。

![3.01_页与记录的关系](D:\study_note\maningning1.github.io\images\mysql\3.01_页与记录的关系.png)

页与记录的关系如上图所示，页与页是以双向链表指针相关联，如果要在多个页中查询某个记录，则分为以下两个步骤：

+ 1、定位到记录所在的页；
+ 2、从所在的页中查找到相应的记录；

步骤2从所在页中查找到相应的记录可以使用到页结构中的Page Directory实现在页中的查询复杂度为`O(logn)`，但是步骤1中定位到所在的页则需要遍历所有的页，这样的话就会有很多随机IO操作，影响查询效率。索引的目的也就是为了降低这种随机IO。

## 索引方案

### 页中存储记录

首先新建一张表，并使用COMPACT行格式来实际存储记录，并且此处会用到记录头信息的record_type和next_record，记录图绘制如下所示：

```shell
create table index_demo(
	c1 int,
	c2 int,
	c3 char(1),
	primary key(c1)
) row_format=compact;
```

![3.02_索引记录图](D:\study_note\maningning1.github.io\images\mysql\3.02_索引记录图.png)

+ record_type：表示记录的类型：0表示普通记录，1表示目录项记录，2表示Infimum记录，3表示Supremum记录；
+ next_record：表示从当前记录的真实数据到下一项记录的真实数据的距离，实质上是个指针；

为了方便展示，假设一个索引页中只能存放3条记录（实际上可以存放上千条记录），则在页中的示意图如下图所示：

![3.03_记录在页中的示意图](D:\study_note\maningning1.github.io\images\mysql\3.03_记录在页中的示意图.png)

假设在表中插入4条数据，其页结构如下所示：

![3.04_数据记录](D:\study_note\maningning1.github.io\images\mysql\3.04_数据记录.png)

此时共4条记录，如果此时在表中插入主键值为4的记录，记录需要保证“下一个索引页中的用户记录主键值必须大于上一个索引页用户记录的主键值”，故会先将主键值为5的这条记录先移动到页9中，再将主键值为4的记录插入到页5中，这个过程也称为页分裂，移动后示意图如下所示：

![3.05_插入值后的数据记录](D:\study_note\maningning1.github.io\images\mysql\3.05_插入值后的数据记录.png)

在一张表中如果插入了多个值，则会存在多个页，如果想要在多个页中快速定位到某条记录所在的页，就需要一个目录项，这个目录项包括两个部分：

+ key：页的用户记录中的最小主键值；
+ page_no：页号；

加入目录项后结构如下所示：

![3.06_目录项下的数据记录](D:\study_note\maningning1.github.io\images\mysql\3.06_目录项下的数据记录.png)

### InnoDB索引方案

InnoDB将目录项也放在索引页中存储，不过目录项中仅有主键和页号，此时采用记录头信息中的record_type标识该记录为目录项，其结构如下所示：

![3.07_将目录项放入页中](D:\study_note\maningning1.github.io\images\mysql\3.07_将目录项放入页中.png)

假设索引页中仅能存放4条目录项，则如果再插入记录后，将会再分裂出新的页保存数据，此时目录项就也需要分裂出新的一个页保存多的目录项，这是就需要生成一个更高级的目录，其结构如下所示：

![3.08_多层目录结构下的数据记录](D:\study_note\maningning1.github.io\images\mysql\3.08_多层目录结构下的数据记录.png)

## B+树

上文所描述的组织数据的形式就是叫**B+树**的数据结构，其结构如下所示，其中最底层的节点用于存放用户数据，其称为叶子节点或叶节点，其余用于存放目录项记录的节点称为非叶子节点或内节点，最上面那个节点称为根节点。

![3.09_B+树](D:\study_note\maningning1.github.io\images\mysql\3.09_B+树.png)

## 索引类型划分

### 数据结构角度

从数据结构角度，索引类型有以下几种：

#### Hash索引

Hash索引是InnoDB存储引擎提供的特性功能，InnoDB会监控到某个索引经常使用，就会内部自己创建一个Hash索引。通过Hash索引推导出记录的地址，直接一次就能查到数据，而B+Tree索引需要查询多次节点。

**优点**：

+ 索引自身只存储对应的Hash值，查找速度非常快；

**缺点**：

+ Hash算法具有随机性，所以索引数据是无序的，无法用于排序；
+ 由于Hash算法的随机性，也无法模糊匹配、比较大小等，仅支持等值查找；
+ 存在Hash冲突；

#### B+树索引

前文已经对B+Tree这种数据结构做了大概的介绍，B+Tree也是InnoDB和MyISAM存储引擎模式的索引类型，相对于Hash索引，B+Tree虽然查找单条记录的速度没有Hash索引快，但是其更适合排序等操作，同时其利用了磁盘预读原理，每次加载时将一个页的数据加载到内存中，大大降低了磁盘I/O的读取。

#### FULLTEXT索引

FULLTEXT索引，也即全文索引，是用来通过关键字的匹配进行查询过滤的，在大量的文本数据检索中，其效率远超'like + %'。

#### R-Tree索引

### 物理存储角度

#### 聚簇索引

将数据存储与索引放到一块，这样找到索引也就找到了数据，InnoDB引擎的主键索引就是聚簇索引，这也是为什么InnoDB引擎中必须要有主键的原因。

#### 非聚簇索引

将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，InnoDB引擎的普通索引（二级索引）的叶子节点就是记录了主键值，再通过回表的方式查找相应数据；MyISAM引擎中的索引都是非聚簇索引，其通过索引找到磁盘上相应的数据。

### 逻辑角度

#### 主键索引

在InnoDB中，主键索引就是聚簇索引，其叶子节点存放的是整行数据。

#### 普通索引

主键索引只有在搜索条件是主键时才能发挥作用，如果以其他列作为搜索条件就需要新建一颗B+树，其叶子节点存放的是主键的值，需要进行回表操作才能得到全量数据，这种B+树叫做普通索引（也称非主键索引或者二级索引），其结构如下所示：

![3.10_二级索引](D:\study_note\maningning1.github.io\images\mysql\3.10_二级索引.png)

#### 复合索引

复合索引，也称联合索引，指在两个或更多列上的索引，假设我们想要在B+树中按照c2，c3两列的大小进行排序，则c2和c3的复合索引就表示了：

+ 先把各个记录和页按照c2列进行排序；
+ 在c2列相同的情况下，再采用c3列进行排序；

其结构如下所示：

![3.11_复合索引](D:\study_note\maningning1.github.io\images\mysql\3.11_复合索引.png)

#### 唯一索引

唯一索引就是指索引的值是唯一的，如果插入一条与现有索引值相等的新行，则会发生错误，唯一索引的列运行有null值。

#### 前缀索引

前缀索引就是为字符串的前几个字符创建索引，因为前缀也是排好序的，定位到前缀后再从中搜索，当要索引的列字符很多时，索引则会很大且变慢，于是就可以只索引列开始的部分字符串，节约索引空间，提高索引的效率。

## 索引使用建议

**只为用于搜索、排序或分组的列创建索引**

只需要为搜索、排序、分组的列建立索引，不要滥用索引，索引也会影响插入效率等。

**考虑索引列中不重复值的个数**

如果二级索引重复个数多，会导致回表的代价大，会产生多次回表操作。

**索引列的类型尽量小**

索引列的数据类型越小，索引占用的存储空间就越少，一个索引页就可以存放更多的记录，就可以减少磁盘IO。

**为列前缀建立索引**

前缀索引可以节约索引空间，提高索引效率，但是不能进行排序，因为其无法对除开前缀的其他部分排序。

**覆盖索引**

覆盖索引是指索引覆盖所有搜索的列，这样就可以避免回表导致的性能损耗，故查询时最好不要使用*。

**让索引列以列名的形式在搜索条件中单独出现**

对于如下两个查询语句，虽然语义相同，但是第一条不会走索引列。

```mysql
select * from table where key*2 < 4;
select * from table where key < 4/2;
```

所以查询使用索引列时必须让索引列以列名的形式单独出现在搜索条件中。

**新插入记录时主键大小对效率的影响**

主键值最好是递增的，如果不是会导致页分裂很多，造成性能损耗。

**冗余和重复索引**

不要滥用索引，索引也会影响插入效率等。