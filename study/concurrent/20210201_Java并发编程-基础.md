# Java并发编程-基础

## 概述

CPU、内存、IO设备的速度差异巨大，为了合理利用CPU的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出来贡献，主要为：

+ CPU：增加了缓存，以均衡与内存的速度差异，**导致了可见性问题**。
+ 操作系统：增加了进程、线程，以分时复用CPU，进而均衡CPU与IO设备的速度差异，**导致了原子性问题**。
+ 编译程序：优化了指令执行次序，使得缓存能够得到更加合理的利用，**导致了有序性问题**。

## Java内存模型

Java并发采用的是共享内存模型，即线程之间共享共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式进行通信，整个通信过程对程序员完全透明。

Java线程之间的通信由JMM（Java内存模型）控制，其决定一个线程对共享变量的写入何时对另一个线程可见，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读、写共享变量的副本，本地内存是JMM的一个抽象概念，并不真实存在，它覆盖了缓存、写缓冲区，寄存器以及其他的硬件和编译器优化。其抽象示意图如下所示：

![1.01_JMM内存模型](D:\study_note\maningning1.github.io\images\concurrent\1.01_JMM内存模型.png)

所以，如果线程A要与线程B通信的话，则必须：

+ 1、线程A把本地内存A中更新过的共享变量刷新到主内存中；
+ 2、线程B到主内存中去读取线程A之前已更新过的共享变量；

![1.02_线程间的通信](D:\study_note\maningning1.github.io\images\concurrent\1.02_线程间的通信.png)

## 重排序

### 概念

在执行程序时为了提高性能，编译器和处理器通常会对指令做重排序，重排序主要分三种类型：

+ **编译器优化的重排序**：编译器在不改变单线程程序语义的前提下，可以安排语句的执行顺序；
+ **指令级并行的重排序**：现代处理器采用了指令集并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；
+ **内存系统的重排序**：由于处理器使用缓存和读/写缓冲区，使得加载和存储操作好像是在乱序执行；

![1.03_重排序](D:\study_note\maningning1.github.io\images\concurrent\1.03_重排序.png)

### 内存屏障

在上图中，1属于编译器重排序，2、3属于处理器重排序，对于处理器重排序，JMM会要求java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障来禁止特定类型的冲利器重排序。

### happens-before

从JDK5开始，Java使用新的JSR-133内存模型，提出了happens-before的概念，阐述操作之间的内存可见性：如果一个操作执行的结果需要对另一个操作可见，那么这两个操作必须存在happens-before的关系，happens-before规则如下：

+ 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作；
+ 监视器锁规则：对一个监视器锁的解锁，happens-before于随后对这个监视器的加锁；
+ volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读；
+ 传递性：如果A happens-before B，且B happens-before C，则A happens-before C;

## 线程安全

一个类在可以被多个线程安全调用时就是线程安全的，可以将共享数据按照安全程度的强弱分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容、线程对立。

### 不可变

不可变的对象一定是线程安全的，不需要再采用任何的线程安全保障措施，因为它不可能存在在多个线程中不一致的情况。

不可变类型：

+ final关键字修饰的**基本数据类型**；
+ String
+ 枚举类型
+ Number部分子类，如Long、Double、BigInteger、BigDecimal等，原子类则是可变的；
+ 集合类型也可以使用`Collections.unmodifiableXXX()`方法获取一个不可变的集合；

### 绝对线程安全

不管运行时环境如何，调用者都不需要任何额外的同步措施。

### 相对线程安全

相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施，但是对于一些特定顺序的连续调用就可能需要在调用端使用额外的同步手段来保证调用的正确性。如Vector、HashTable、`Collections.synchronizedCollection()`都是属于相对线程安全的类型。

### 线程兼容

线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，如ArrayList、HashTable等。

### 线程对立

线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。

## 线程安全的实现方法

### 互斥同步

互斥同步又称为阻塞同步，属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁(这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁)、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

在Java中采用synchronize或者Lock实现。

### 非阻塞同步

随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其他线程争用共享数据，那就操作成功，否则会不断重试，知道成功为止。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。

乐观锁需要操作和冲突检测这两个步骤具有原子性，只能靠硬件来完成。硬件支持原子性操作最典型的就是：CAS（Compare-and-Swap，比较并交换），CAS指令需要有3个操作数，分别是内存地址V、旧的预期值A和新值B，当执行操作时，只有当V的值等于A，才将V的值更新为B。

### 无同步方案

如果一个方法不涉及共享数据，就不需要任何同步方案来保证正确性。

+ 栈封闭：多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的；
+ ThreadLocal；
+ 可重入代码：不依赖存储在堆上的数据和资源；

## 线程状态转换

+ 新建（New）：创建后尚未启动；

+ 可运行（Runnable）：可能在运行，也可能正在等待CPU时间片，包含了操作系统线程状态的Running和Ready；

+ 阻塞（Blocking）：等待获取一个排它锁，如果其他线程释放了锁就会结束此状态；

+ 无限期等待（Waiting）：等待其他线程显示地唤醒，否则不会被分配CPU时间片；

  | 进入方法                                 | 退出方法                               |
  | ---------------------------------------- | -------------------------------------- |
  | 没有设置Timeout参数的`Object.wait()`方法 | `Object.notify()`/`Object.notifyAll()` |
  | 没有设置Timeout参数的`Thread.join()`方法 | 被调用的线程执行完毕                   |
  | `LockSupport.park()`方法                 |                                        |

+ 限期等待（Timed Waiting）：无需等待其他线程显式地唤醒，在一定时间之后会被系统自动唤醒；

  | 进入方法                               | 退出方法                                        |
  | -------------------------------------- | ----------------------------------------------- |
  | `Thread.sleep()`方法                   | 时间结束                                        |
  | 设置了Timeout参数的`Object.wait()`方法 | 时间结束/`Object.notify()`/`Object.notifyAll()` |
  | 设置了Timeout参数的`Thread.join()`方法 | 时间结束/被调用的线程执行完毕                   |
  | `LockSupport.parkNanos()`方法          |                                                 |
  | `LockSupport.parkUntil()`方法          |                                                 |

+ 死亡：可以是线程结束任务之后结束或者产生了异常而结束；

## 线程使用方式

线程使用方式有三种：

+ 实现Runnable接口；
+ 实现Callable接口，与Runnable相比有返回值，返回值通过FutureTask封装；
+ 继承Thread类；

