# Hash

> 平时在java中，有用到HashMap等，在MySQL中也会涉及到Hash索引，现在的区块链技术的底层原理之一也是Hash，本文对Hash做一个记录。

## 什么是Hash

Hash，翻译为中文有哈希、散列、杂凑等，是指把任意长度的输入通过一定的算法变成**固定长度的输出**的过程，其是可以从任何一种数据中创建小的数字“指纹”的方法。

一个优秀的Hash算法具有以下几个特点：

+ **抗碰撞能力强**

  对应任意两个不同的数据块，hash值相同的概率极小。

+ **抗篡改能力强**

  对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。

+ **不能反向推导**

  因为Hash的输出是固定长度，所以输出是有限的，必然会存在不同的输入得到相同输出的情况，所以Hash算法是不能反向推导出原始数据的。

+ **执行高效**

  长的文本也能快速地计算出哈希值。

## Hash碰撞

由于Hash函数产生的Hash值是有限的，必然会存在不同的输入得到相同输出的情况，这就是所谓的Hash碰撞，也称为Hash冲突。

### 解决方法

解决哈希冲突的方法一般有：开放定址法、链地址法（拉链法）、再哈希法、建立公共溢出区等方法。

#### 开放地址法

开放地址法是指从冲突的那个单元起，按照一定次序从哈希表中找到一个空闲的单位，然后把冲突的元素存入到该单元，**所以开放定址法需要的表长度要大于等于所需要存放的元素**。

开放地址法主要包括线行探查法、平方探查法、双散列函数探查法。

+ **线行探查法**

  线性探查法是指从发生冲突的单元起，依次判断下个单元是否为空，为空则插入；当达到最后一个单元时在从表首依次判断。

  不过该方法若是反复插入同一个槽，则会存在太多重复操作。

  比如对于下图所示情况，哈希表长为6，首先插入8，由于8%6=2，故应插入第3个槽中，由于第3个槽有值则判断下一个单位并插入，不过对于数据13的插入，则需要判断3次，效率太低。

  ![线性探测法1](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%951.png?raw=true)

  ![线性探测法2](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%B5%8B%E6%B3%952.png?raw=true)

+ **平方探查法**

  平方探查法是指在发生冲突初依次加入1的平方，随之是2的平方，3的平方，直至不发生冲突，该方法主要用于解决线性探查法的集聚问题。

+ **伪随机探查法**

  通过随机函数随机生成一个数，在原来值的基础上加上随机数，直至不发生哈希冲突。

#### 链地址法（拉链法）

如下图所示，链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。

Java中的HashMap就是采用的该方式解决Hash冲突，在java8之后，链表长度大于8之后，会转换为红黑树存储。在jdk1.8之前是使用的头插法，在jdk1.8中是尾插法。

![链地址法](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95.png?raw=true)

#### 再哈希法

再哈希法是指构造多个哈希函数，当H1发生冲突时，采用H2进行计算，直到不再发生冲突。这种方法不易产生聚集，但是增加了计算时间。

#### 建立公共溢出区

将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

## Hash的应用

Hash主要应用在数据结构中以及密码学中，其主要的应用有如下几个方面：

### 信息加密

服务端保存用户的密码时需要对密码进行Hash加密，不然很容易被黑客窃取数据来登录，最简单的加密方法就是直接使用MD5加密，不过此方法也很容易被反向查询出来。

针对这种问题，解决方法就是"**加盐**"，即利用盐与用户密码组合进行加密，增加了反向查询的复杂度。

### 唯一标识

对大数据做信息摘要，通过一个较短的二进制编码来表示。

### 数据校验

校验数据的完整性和正确性。

在进行BT下载时，会将文件分成多个文件块，并行下载后再进行组装，可以对文件块去Hash值，下载完成后再将文件块中的Hash值进行比对。

### 负载均衡

对客户端IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算，最终得到的值就是应该被路由到的服务器编号。

这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。

### 分布式存储

面对海量数据，为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。借用前面数据分片的思想，即通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号。

但是，后期如果需要新增或者下线个数发生改变，会造成缓存数据全部失效，解决这个问题，就需要**一致性哈希算法**。

## 一致性哈希算法

一致性Hash是一种特殊的Hash算法，由于其均衡性、持久性和映射特点，被广泛应用于负载均衡领域，如nginx和memcached都采用了一致性Hash来作为集群负载均衡的方案。负载均衡利用了Hash可以将相近数据变成完全随机的字符串这个特性，对于大量请求，实现了压力平均化。

### Hash算法存在的问题

假设后台服务节点数为N，前台携带key发起请求，负载均衡算法通过将key进行hash后取模运算（hash(key)%N），来计算请求分发到哪个节点，对于分布式缓存或者分布式数据库等场景，增加或者减少节点会导致几乎所有的key重新映射，造成缓存雪崩。

一致性Hash算法的目标就是当K个请求key发起请求时。后台增减节点，只会引起K/N的key发生重新映射。即一致性Hash算法，在后台节点稳定时，同一key的每次请求映射到的节点是一样的。而当后台节点增减时，该算法尽量将K个key映射到与之前相同的节点上。

### 判定Hash算法好坏的定义

判定Hash算法好坏主要根据以下四个定义进行判断（根据下文一致性Hash算法来理解这四个定义可能会更好理解一些）：

+ **平衡性**：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。
+ **单调性**：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。
+ **分散性**：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。
+ **负载**：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。

对于分布式集群，如果对节点进行增加或者删除操作，很多原有的数据就无法找到，违反了单调性原则。

### 一致性Hash算法的思想

首先针对Hash算法存在的问题如下图所示，假设目前有3个槽，存放对应的key，如果新增一个槽，则所有缓存的key将会被打乱。

![一致性Hash算法1](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%951.png?raw=true)

如果将槽预留，，则可以将对应的key存放在附近存在槽的位置。如下图所示，虚线表示预留的槽，就可以将2,3号的数据存放在1中，将5,6号的数据存放在4中，那么0号槽的数据呢？则可以将整个空间看做一个环状，将数据以顺时针方向进行存放，这就是一致性Hash算法的思想。

![一致性Hash算法2](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%952.png?raw=true)

### 一致性Hash算法的实现

#### 环形Hash空间

按照常用的Hash算法将key的Hash值放入2^32个槽中，并将头尾相连成一个闭合的环形。

如下图所示，蓝点代表节点，黄点代表通过Hash算法得到的key值，将key值映射到环中（一般情况下对机器的hash计算是采用机器的IP或者机器唯一的别名作为输入值），然后以顺时针的方向计算，将所有对象存储到离自己最近的机器中。

![一致性哈希算法3](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%953.png?raw=true)

#### 机器的删除与添加

机器的删除与添加图例如下所示，分别删除NODE3以及添加NODE5，只有少量的key会映射到不同的节点上，一致性哈希算法在保持了单调性的同时，还是数据的迁移达到了最小，这样的算法对分布式集群来说是非常合适的，避免了大量数据迁移，减小了服务器的的压力。

![一致性哈希算法4](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%954%E5%88%A0%E9%99%A4%E6%9C%BA%E5%99%A8.png?raw=true)

![一致性哈希算法5](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%955%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%99%A8.png?raw=true)

#### 虚拟节点

通过上文机器的删除与添加图解，可以得出一致性哈希算法满足了单调性和负载均衡的特性以及一般hash算法的分散性，但不能满足平衡性，其原因如下图所示，假如1,2两个个节点全部删除，则会导致大量的key存储在NODE3中，造成了不平衡。

![一致性哈希算法6虚拟节点](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%956%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9.png?raw=true)

为了尽可能满足平衡性，引入了**虚拟节点（ virtual node）**，让一个节点对应多个虚拟节点，如下图所示。

![一致性哈希算法7虚拟节点](https://github.com/maningning1/maningning1.github.io/blob/main/images/hash/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%957%E8%99%9A%E6%8B%9F%E8%8A%82%E7%82%B9.png?raw=true)

## 引用

[散列函數](https://www.zhihu.com/question/26762707/answer/890181997 )

[关于哈希的一切！](https://segmentfault.com/a/1190000023872036)

什么是 hash？ - 之幽的回答 - 知乎 https://www.zhihu.com/question/26762707/answer/40119521

什么是 hash？ - 腾讯技术工程的回答 - 知乎 https://www.zhihu.com/question/26762707/answer/890181997

[解决哈希冲突的常用方法分析](https://www.jianshu.com/p/4d3cb99d7580)

[【算法】理解哈希算法 hash 和常见应用](https://blog.csdn.net/sscc_learning/article/details/88658511)

聊聊一致性哈希 - 刘梦馨的文章 - 知乎 https://zhuanlan.zhihu.com/p/24440059

[一致性Hash在负载均衡中的应用](https://juejin.cn/post/6844903670430040078)

 [算法：什么是一致性Hash算法](https://www.cnblogs.com/54chensongxia/p/11596962.html)